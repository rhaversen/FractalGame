// Fractal shader utilities combining Mandelbulb ray marching and Mandelbrot perturbation helpers

#define MARCH_MAX_STEPS 200
#define MARCH_MAX_DISTANCE 500.0
#define DE_MAX_ITER 25
#define DE_BAILOUT 10.0

#define MANDELBROT_BAILOUT_SQ 4.0
#define MANDELBROT_W_LIMIT 1000000.0

#define HIT_STATUS_HIT 1
#define HIT_STATUS_MISS_DISTANCE 2
#define HIT_STATUS_MISS_STEPS 3

struct MarchResult
{
	float distance;
	int steps;
	int hitStatus;
	int totalDEIterations;
};

struct MandelbrotPerturbationResult
{
	float3 Color;
	float SmoothIteration;
	float EscapeIteration;
	float InsideMask;
	float2 LastZ;
	float2 Perturbation;
};

struct FractalFunctions
{
	// Computes the world-space radius that a sphere must have to appear 1 pixel tall on screen at a given distance.
	static float GetPixelWorldRadius(float distance)
	{
		return distance * ResolvedView.ClipToView._22 / ResolvedView.ViewSizeAndInvSize.y;
	}

	// Mandelbulb distance estimator
	static float MandelbulbDE(float3 pos, float power, out int iterations)
	{
		float3 z = pos;
		float dr = 1.0;
		float r = 0.0;
		
		for (iterations = 0; iterations < DE_MAX_ITER; iterations++)
		{
			r = length(z);
			if (r > DE_BAILOUT)
				break;
			
			// Convert to spherical coordinates
			float theta = acos(z.z / r);
			float phi = atan2(z.y, z.x);
			dr = pow(r, power - 1.0) * power * dr + 1.0;
			
			// Scale and rotate the point
			float zr = pow(r, power);
			theta = theta * power;
			phi = phi * power;
			
			// Convert back to Cartesian coordinates
			float sinTheta = sin(theta);
			z = zr * float3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta));
			z += pos;
		}
		
		return 0.5 * log(r) * r / dr;
	}

	// Ray marching
	static MarchResult MarchFractal(float3 rayOrigin, float3 rayDir, float power)
	{
		float totalDist = 0.0;
		int steps = 0;
		int totalDEIterations = 0;

		while (totalDist < MARCH_MAX_DISTANCE && steps < MARCH_MAX_STEPS)
		{
			steps++;
			float3 pos = rayOrigin + rayDir * totalDist;
			
			int deIterations;
			float distance = MandelbulbDE(pos, power, deIterations);
			totalDEIterations += deIterations;

			float pixelSize = GetPixelWorldRadius(totalDist);

			if (distance <= pixelSize)
			{
				MarchResult result;
				result.distance = totalDist;
				result.steps = steps;
				result.hitStatus = HIT_STATUS_HIT;
				result.totalDEIterations = totalDEIterations;
				return result;
			}

			float stepSize = max(distance, pixelSize * 0.5);
			totalDist += stepSize;
		}

		MarchResult result;
		result.distance = totalDist;
		result.steps = steps;
		result.hitStatus = (totalDist >= MARCH_MAX_DISTANCE) ? HIT_STATUS_MISS_DISTANCE : HIT_STATUS_MISS_STEPS;
		result.totalDEIterations = totalDEIterations;
		return result;
	}

	static float3 RenderFractal(float2 screenUV, float3 sceneColor, float power)
	{
		// Get camera parameters
		float3 cameraOrigin = LWCHackToFloat(ResolvedView.WorldCameraOrigin);

		// Convert screen UV to clip space
		float2 clipXY = screenUV * 2.0 - 1.0;
		clipXY.y = -clipXY.y;

		float4 clipPos = float4(clipXY, 1.0, 1.0);
		float4 viewPos = mul(clipPos, ResolvedView.ClipToView);
		viewPos.xyz /= viewPos.w;

		// Transform view direction to world space
		float3 worldDir = normalize(mul(viewPos.xyz, (float3x3)ResolvedView.ViewToTranslatedWorld));

		// Scale down the camera origin for better framing
		float3 rayOrigin = cameraOrigin * 0.001;
		float3 rayDir = worldDir;

		// Ray march
		MarchResult finalResult = MarchFractal(rayOrigin, rayDir, power);

		// Calculate color based on total steps taken
		float stepFactor = saturate(finalResult.steps / float(MARCH_MAX_STEPS));
		float t = sqrt(stepFactor);
		
		// Gradient color stops
		float3 almostBlack = float3(0.0, 0.0, 0.05);
		float3 deepBlue = float3(0.05, 0.15, 0.3);
		float3 vibrantBlue = float3(0.2, 0.4, 0.8);
		float3 brightBlue = float3(0.6, 0.8, 1.0);
		
		// Blend through gradient
		float range1 = saturate(t / 0.15);
		float range2 = saturate((t - 0.15) / 0.25);
		float range3 = saturate((t - 0.4) / 0.6);
		float3 fractalColor = lerp(lerp(lerp(almostBlack, deepBlue, range1), vibrantBlue, range2), brightBlue, range3);

		// Add green tint based on total DE iterations
		float iterFactor = saturate(finalResult.totalDEIterations / float(DE_MAX_ITER * finalResult.steps));
		
		if (iterFactor > 0.1)
		{
			float greenAmount = (iterFactor - 0.1) / 0.9;
			greenAmount = pow(greenAmount, 2.0);
			fractalColor = lerp(fractalColor, float3(0.3, 0.5, 0.6), greenAmount);
		}

		if (iterFactor > 0.9)
		{
			float greenAmount = (iterFactor - 0.9) / 0.1;
			greenAmount = pow(greenAmount, 5.0);
			fractalColor = lerp(fractalColor, float3(0.3, 0.9, 0.7), greenAmount);
		}

		if (finalResult.hitStatus == HIT_STATUS_HIT)
		{
			return fractalColor;
		}
		else if (finalResult.hitStatus == HIT_STATUS_MISS_DISTANCE)
		{
			float fogAmount = pow(stepFactor, 0.1);
			return lerp(sceneColor, fractalColor, fogAmount);
		}
		else
		{
			return fractalColor;
		}
	}

	static float2 ComplexMul(float2 a, float2 b)
	{
		return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
	}

	static float MagnitudeSq(float2 value)
	{
		return dot(value, value);
	}

	static float3 EvaluateMandelbrotPalette(float t)
	{
		float3 a = float3(0.35, 0.22, 0.56);
		float3 b = float3(0.25, 0.35, 0.35);
		float3 c = float3(1.0, 0.9, 0.7);
		float3 d = float3(0.0, 0.33, 0.67);
		return a + b * cos(6.2831853 * (c * t + d));
	}

	static float2 ScreenPosToUV(float4 screenPos)
	{
		float wComponent = max(screenPos.w, 1.0e-6);
		return screenPos.xy / wComponent;
	}

	static MandelbrotPerturbationResult RenderMandelbrotPerturbation(
		float2 screenUV,
		float2 viewportCenter,
		float2 viewportScaleAspect,
		float2 referenceHi,
		float2 referenceLo,
		float maxIterations,
		Texture2D<float4> orbitTexture)
	{
		MandelbrotPerturbationResult result;
		result.Color = float3(1.0, 0.0, 1.0);
		result.SmoothIteration = 0.0;
		result.EscapeIteration = 0.0;
		result.InsideMask = 0.0;
		result.LastZ = float2(0.0, 0.0);
		result.Perturbation = float2(0.0, 0.0);

		if (maxIterations <= 0.0)
		{
			return result;
		}

		uint orbitWidth;
		uint orbitHeight;
		orbitTexture.GetDimensions(orbitWidth, orbitHeight);
		if (orbitWidth == 0u)
		{
			return result;
		}

		int orbitLength = min((int)maxIterations, (int)orbitWidth);
		if (orbitLength <= 0)
		{
			return result;
		}

		float2 uv = screenUV;
		float aspect = viewportScaleAspect.y > 0.0 ? viewportScaleAspect.y : (ResolvedView.ViewSizeAndInvSize.x * ResolvedView.ViewSizeAndInvSize.w);
		float2 scale = float2(viewportScaleAspect.x, viewportScaleAspect.x * aspect);
		float2 planePoint = viewportCenter + (uv - 0.5) * scale;

		float2 deltaC = (planePoint - referenceHi) - referenceLo;

		float2 w = float2(0.0, 0.0);
		float2 zPerturbed = referenceHi;
		float smoothIter = (float)orbitLength;
		float escapeIter = (float)orbitLength;
		bool escaped = false;

		[loop]
		for (int iter = 0; iter < orbitLength; ++iter)
		{
			float4 orbitSample = orbitTexture.Load(int3(iter, 0, 0));
			float2 zRef = orbitSample.xy;
			float2 dzdc = orbitSample.zw;

			float2 perturbation = ComplexMul(dzdc, deltaC) + w;
			float2 z = zRef + perturbation;
			zPerturbed = z;

			float magSq = MagnitudeSq(z);
			if (magSq > MANDELBROT_BAILOUT_SQ)
			{
				escaped = true;
				escapeIter = (float)iter;
				float magnitude = sqrt(magSq);
				float safeLog = max(1.0e-6, log(max(1.0000001, magnitude)));
				smoothIter = (float)iter + 1.0 - log2(safeLog);
				break;
			}

			float2 wSquared = ComplexMul(w, w);
			float2 twoZRef = zRef * 2.0;
			w = ComplexMul(twoZRef, w) + wSquared + deltaC;

			float maxComponent = max(abs(w.x), abs(w.y));
			if (maxComponent > MANDELBROT_W_LIMIT)
			{
				// Indicates the perturbation drifted too far from the reference orbit.
				return result;
			}
		}

		float escapedMask = escaped ? 1.0 : 0.0;
		float normalized = smoothIter / max((float)orbitLength, 1.0);
		normalized = saturate(normalized);
		float3 palette = EvaluateMandelbrotPalette(normalized);
		float3 interiorColor = float3(0.02, 0.02, 0.05);

		result.Color = lerp(interiorColor, palette, escapedMask);
		result.SmoothIteration = smoothIter;
		result.EscapeIteration = escapeIter;
		result.InsideMask = 1.0 - escapedMask;
		result.LastZ = zPerturbed;
		result.Perturbation = w;
		return result;
	}

	static float3 RenderMandelbrotPerturbationColor(
		float2 screenUV,
		float2 viewportCenter,
		float2 viewportScaleAspect,
		float2 referenceHi,
		float2 referenceLo,
		float maxIterations,
		Texture2D<float4> orbitTexture)
	{
		MandelbrotPerturbationResult result = RenderMandelbrotPerturbation(screenUV, viewportCenter, viewportScaleAspect, referenceHi, referenceLo, maxIterations, orbitTexture);
		return result.Color;
	}

	static float4 RenderMandelbrotPerturbationPacked(
		float2 screenUV,
		float2 viewportCenter,
		float2 viewportScaleAspect,
		float2 referenceHi,
		float2 referenceLo,
		float maxIterations,
		Texture2D<float4> orbitTexture)
	{
		MandelbrotPerturbationResult result = RenderMandelbrotPerturbation(screenUV, viewportCenter, viewportScaleAspect, referenceHi, referenceLo, maxIterations, orbitTexture);
		return float4(result.Color, result.SmoothIteration);
	}
};

// Usage in material custom node:
// #include "/Project/FractalMaterial.usf"
// FractalFunctions FF;
// return FF.RenderFractal(ScreenPosition, SceneColor, Power).rgb;
//
// Perturbation:
// #include "/Project/FractalMaterial.usf"
// FractalFunctions FF;
// return FF.RenderMandelbrotPerturbationColor(ScreenPosition, ViewportCenter, ViewportScaleAspect, ReferenceHi, ReferenceLo, MaxIterations, OrbitTexture);
//
// Custom node inputs (in order):
// 1. ScreenPosition (float2) - from ScreenPosition node
// 2. ViewportCenter (float2) - from Vector Parameter "ViewportCenter" (use .rg)
// 3. ViewportScaleAspect (float2) - from Vector Parameter "ViewportScaleAspect" (use .rg)
// 4. ReferenceHi (float2) - from Vector Parameter "ReferenceHi" (use .rg)
// 5. ReferenceLo (float2) - from Vector Parameter "ReferenceLo" (use .rg)
// 6. MaxIterations (float) - from Scalar Parameter "MaxIterations"
// 7. OrbitTexture (Texture2D) - from Texture Object Parameter "OrbitTexture"