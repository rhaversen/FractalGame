// FractalMaterial.usf
// Combined fractal shader functions for use in material custom nodes

struct FractalFunctions
{
    float FractalDE(float3 pos, float Power)
    {
        float3 z = pos;
        float dr = 1.0;
        float r = 0.0;

        for (int i = 0; i < 20; i++) // Iterations = 20
        {
            r = length(z);
            if (r > 4.0) break; // Bailout = 4.0

            // Spherical coordinates
            float theta = acos(z.z / r);
            float phi = atan2(z.y, z.x);
            dr = pow(r, Power - 1.0) * Power * dr + 1.0;

            // Scale and rotate
            float zr = pow(r, Power);
            theta *= Power;
            phi *= Power;

            z = zr * float3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
            z += pos;
        }

        return 0.5 * log(r) * r / dr;
    }

    float3 EstimateNormal(float3 p, float Power) 
    {
        float eps = 0.001;
        return normalize(float3(
            FractalDE(p + float3(eps, 0, 0), Power) - FractalDE(p - float3(eps, 0, 0), Power),
            FractalDE(p + float3(0, eps, 0), Power) - FractalDE(p - float3(0, eps, 0), Power),
            FractalDE(p + float3(0, 0, eps), Power) - FractalDE(p - float3(0, 0, eps), Power)
        ));
    }

    float RaymarchFractal(float3 RayOrigin, float3 RayDir, float Power, out float3 Normal)
    {
        float totalDist = 0.0;
        for (int step = 0; step < 128; step++) // MAX_STEPS = 128
        {
            float3 pos = RayOrigin + RayDir * totalDist;
            float dist = FractalDE(pos, Power);

            if (dist < 0.001) // HIT_THRESHOLD = 0.001
            {
                Normal = EstimateNormal(pos, Power);
                return totalDist;
            }

            totalDist += dist;
            if (totalDist > 1000.0) break; // FAR_PLANE = 1000.0
        }
        Normal = float3(0, 0, 0);
        return -1.0; // No hit
    }

    // Post-process version that uses UE5's built-in camera parameters
    float3 RenderFractalPostProcess(float2 ScreenPosition)
    {
        // Get camera origin
        float3 CameraOrigin = LWCHackToFloat(ResolvedView.WorldCameraOrigin);
        
        // Convert screen position to clip space
        float2 ClipXY = ScreenPosition * 2.0 - 1.0;
        
        // Use the inverse projection approach that should work in UE5
        float4 ClipPos = float4(ClipXY, 1.0, 1.0);
        float4 ViewPos = mul(ClipPos, ResolvedView.ClipToView);
        ViewPos.xyz /= ViewPos.w;
        
        // Transform view direction to world space
        float3 WorldDir = normalize(mul(ViewPos.xyz, (float3x3)ResolvedView.ViewToTranslatedWorld));
        
        // Now that ray casting works, let's implement the fractal!
        // Scale down camera position to fractal space
        float3 rayOrigin = CameraOrigin * 0.01; // Scale factor for fractal
        float3 rayDir = WorldDir;
        
        float Power = 8.0;
        float3 Normal;
        float dist = RaymarchFractal(rayOrigin, rayDir, Power, Normal);

        if (dist > 0.0)
        {
            // We hit the fractal!
            float3 hitPos = rayOrigin + rayDir * dist;
            
            // Simple lighting
            float3 lightDir = normalize(float3(0.8, 0.8, 0.5));
            float diffuse = saturate(dot(Normal, lightDir)) * 0.7 + 0.3;
            
            // Color based on normal and position
            float3 color = abs(Normal) * diffuse;
            color = lerp(color, float3(1.0, 0.5, 0.2), 0.3); // Add orange tint
            
            return color;
        }
        else
        {
            // Background gradient based on ray direction
            float gradient = dot(rayDir, float3(0, 0, 1)) * 0.5 + 0.5;
            return lerp(float3(0.05, 0.05, 0.15), float3(0.2, 0.1, 0.4), gradient);
        }
    }
};
