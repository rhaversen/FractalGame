// Post-process mandelbulb fractal rendering shader functions for use in material custom node

struct MarchResult
{
	float distance;
	int steps;
};

struct FractalFunctions
{
	// Computes the world-space radius that a sphere must have to appear 1 pixel tall on screen at a given distance.
	static float GetPixelWorldRadius(float distance)
	{
		// This is derived from the projection formula: pixel_size = (world_radius / distance) * screen_height / tan(fov/2)
		// Solving for world_radius when pixel_size = 1 gives:
		return distance * ResolvedView.ClipToView._22 / ResolvedView.ViewSizeAndInvSize.y;
	}

	// Calculates the Distance Estimate (DE) for a point in space to the Mandelbulb set.
	// The DE is the radius of a sphere centered at 'pos' that is guaranteed not to touch the fractal.
	static float FractalDE(float3 pos, float Power)
	{
		float3 z = pos;
		float dr = 1.0;
		float r = 0.0;
		float bailout = 4.0;
		int MaxIter = 120; // A fixed max iteration count is sufficient here.

		for (int i = 0; i < MaxIter; i++)
		{
			r = length(z);
			if (r > bailout)
				break;

			// Spherical coordinates
			float theta = acos(z.z / r);
			float phi = atan2(z.y, z.x);
			dr = pow(r, Power - 1.0) * Power * dr + 1.0;

			// Scale and rotate
			float zr = pow(r, Power);
			theta *= Power;
			phi *= Power;

			z = zr * float3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
			z += pos;
		}

		return 0.5 * log(r) * r / dr;
	}

	// Marching function that can do cone marching (subdivisionFactor > 0) or ray marching (subdivisionFactor = 0)
	// subdivisionFactor: 0 = precise ray marching, >0 = cone marching with that many pixels bundled
	// startDistance & startSteps: allows continuing from where a previous march left off
	static MarchResult MarchFractal(float3 RayOrigin, float3 RayDir, float Power, float subdivisionFactor, float startDistance, int startSteps)
	{
		float totalDist = startDistance;
		float maxDistance = 10.0;
		int maxSteps = 500;
		int steps = startSteps;

		while (totalDist < maxDistance && steps < maxSteps)
		{
			steps++;
			float3 pos = RayOrigin + RayDir * totalDist;
			float distEstimate = FractalDE(pos, Power);

			// Calculate precision threshold based on whether we're cone marching or ray marching
			float pixelSize = GetPixelWorldRadius(totalDist);
			float threshold;
			
			if (subdivisionFactor > 0.0)
			{
				// Cone marching: stop at cone radius or pixel size, whichever is smaller
				float coneRadius = pixelSize * subdivisionFactor;
				threshold = min(coneRadius * 1.25, pixelSize);
			}
			else
			{
				// Ray marching: threshold is a small fraction of pixel size
				threshold = pixelSize * 0.1;
			}

			// Check if we've hit the fractal
			if (distEstimate < threshold)
			{
				MarchResult result;
				result.distance = totalDist;
				result.steps = steps;
				return result;
			}

			// Advance by the distance estimate (with adaptive min step for ray marching)
			float stepSize = distEstimate;
			if (subdivisionFactor == 0.0)
			{
				// Ray marching: enforce minimum step size to avoid getting stuck
				float pixelSize = GetPixelWorldRadius(totalDist);
				float adaptiveMinStep = pixelSize * 0.5;
				stepSize = max(distEstimate, adaptiveMinStep);
			}
			totalDist += stepSize;
		}

		MarchResult result;
		result.distance = totalDist;
		result.steps = steps;
		return result;
	}


	static float3 RenderFractal(float2 screenUV, float3 sceneColor)
	{
		// Get camera parameters
		float3 cameraOrigin = LWCHackToFloat(ResolvedView.WorldCameraOrigin);

		// Convert screen UV to clip space
		float2 clipXY = screenUV * 2.0 - 1.0;
		clipXY.y = -clipXY.y; // Flip Y for clip space

		float4 clipPos = float4(clipXY, 1.0, 1.0);
		float4 viewPos = mul(clipPos, ResolvedView.ClipToView);
		viewPos.xyz /= viewPos.w;

		// Transform view direction to world space
		float3 worldDir = normalize(mul(viewPos.xyz, (float3x3)ResolvedView.ViewToTranslatedWorld));

		// Scale down the camera origin for better framing
		float3 rayOrigin = cameraOrigin * 0.001;
		float3 rayDir = worldDir;

		float Power = 8.0;
		
		// First pass: Cone march with subdivision factor of 12 (bundle ~12 pixels per cone)
		float subdivisionFactor = 12.0;
		MarchResult coneResult = MarchFractal(rayOrigin, rayDir, Power, subdivisionFactor, 0.0, 0);
		
		// Second pass: Ray march from where cone marching left off (subdivisionFactor = 0 for precise marching)
		MarchResult finalResult = MarchFractal(rayOrigin, rayDir, Power, 0.0, coneResult.distance, coneResult.steps);

		// Calculate color based on total steps taken
		float stepFactor = saturate(finalResult.steps / 500.0);
		float t = sqrt(stepFactor);
		
		// Gradient color stops: position -> color
		float  almostBlackPos = 0.0;   float3 almostBlack = float3(0.0, 0.0, 0.05);    // Very few steps
		float  deepBluePos = 0.15;     float3 deepBlue = float3(0.05, 0.15, 0.3);      // Low detail areas
		float  vibrantBluePos = 0.4;   float3 vibrantBlue = float3(0.2, 0.4, 0.8);     // Medium detail
		float  brightBluePos = 1.0;    float3 brightBlue = float3(0.6, 0.8, 1.0);      // Many steps
		
		// Blend through gradient stops
		float range1 = saturate((t - almostBlackPos) / (deepBluePos - almostBlackPos));
		float range2 = saturate((t - deepBluePos) / (vibrantBluePos - deepBluePos));
		float range3 = saturate((t - vibrantBluePos) / (brightBluePos - vibrantBluePos));
		float3 fractalColor = lerp(lerp(lerp(almostBlack, deepBlue, range1), vibrantBlue, range2), brightBlue, range3);

		// Determine hit or miss
		if (finalResult.distance > 0.0)
		{
			// Miss - apply fog based on how close we got
			float fogAmount = pow(stepFactor, 0.1);
			return lerp(sceneColor, fractalColor, fogAmount);
		}
		else
		{
			// Hit
			return fractalColor;
		}
	}
};

// Usage in material custom node:
// #include "/Project/FractalMaterial.usf"
// FractalFunctions FF;
// return FF.RenderFractal(ScreenPosition, SceneColor).rgb;