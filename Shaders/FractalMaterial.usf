// Post-process fractal rendering shader functions for use in material custom node
//
// ADDING NEW FRACTALS - Update these locations:
// 1. Add #define FRACTAL_TYPE_YOURFRACTAL below and increment FRACTAL_TYPE_COUNT
// 2. Add case in FractalDE() switch statement to call your DE function
// 3. Add case in GetScaleFromPower() to define power-to-scale mapping
// 4. Update FractalNames array in FractalHUD.cpp
// 5. Update MaxFractalType in FractalPlayerController.h
// 6. Add implementation using common transformation functions (BoxFold, SphereFold, etc.)
//
// Common transformation building blocks are provided to make hybrid fractals easier.
// Power-to-scale conversion is centralized in GetScaleFromPower() for easy adjustment.

#define FRACTAL_MARCH_MAX_STEPS 200
#define FRACTAL_MARCH_MAX_DISTANCE 500.0
#define FRACTAL_DE_MAX_ITER 25
#define FRACTAL_DE_BAILOUT 10.0

// Fractal type definitions - ADD NEW TYPES HERE and increment COUNT
#define FRACTAL_TYPE_MANDELBULB 0
#define FRACTAL_TYPE_BURNING_SHIP 1
#define FRACTAL_TYPE_JULIA_SET 2
#define FRACTAL_TYPE_MANDELBOX 3
#define FRACTAL_TYPE_INVERTED_MENGER 4
#define FRACTAL_TYPE_KLEINIAN 5
#define FRACTAL_TYPE_APOLLONIAN 6
#define FRACTAL_TYPE_QUATERNION 7
#define FRACTAL_TYPE_SIERPINSKI_TETRAHEDRON 8
#define FRACTAL_TYPE_KALEIDOSCOPIC_IFS 9
#define FRACTAL_TYPE_COUNT 10

#define HIT_STATUS_NONE 0
#define HIT_STATUS_HIT 1
#define HIT_STATUS_MISS_DISTANCE 2
#define HIT_STATUS_MISS_STEPS 3

struct MarchResult
{
	float distance;
	int steps;
	int hitStatus;
	int totalDEIterations;
};

struct DEResult
{
	float distance;
	int iterations;
};

struct SphericalCoords
{
	float r;
	float theta;
	float phi;
};

struct SphereFoldResult
{
	float3 z;
	float dz;
};

struct FractalFunctions
{
	// Convert Cartesian coordinates to spherical
	static SphericalCoords CartesianToSpherical(float3 z)
	{
		SphericalCoords result;
		result.r = length(z);
		result.theta = acos(z.z / result.r);
		result.phi = atan2(z.y, z.x);
		return result;
	}

	// Convert spherical coordinates back to Cartesian
	static float3 SphericalToCartesian(float r, float theta, float phi)
	{
		float sinTheta = sin(theta);
		return r * float3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta));
	}

	// Apply power rotation in spherical domain
	static void RotateSpherical(inout float theta, inout float phi, float power)
	{
		theta *= power;
		phi *= power;
	}

	static DEResult MakeDEResult(float radius, float derivative, int iterations)
	{
		DEResult result;
		result.distance = 0.5 * log(radius) * radius / derivative;
		result.iterations = iterations;
		return result;
	}

	// Computes the world-space radius that a sphere must have to appear 1 pixel tall on screen at a given distance.
	static float GetPixelWorldRadius(float distance)
	{
		// This is derived from the projection formula: pixel_size = (world_radius / distance) * screen_height / tan(fov/2)
		// Solving for world_radius when pixel_size = 1 gives:
		return distance * ResolvedView.ClipToView._22 / ResolvedView.ViewSizeAndInvSize.y;
	}

	// ============================================================================
	// POWER FRACTALS - Algebraic power iteration (z^n + c)
	// Uses spherical coordinates for smooth, organic shapes
	// ============================================================================

	static DEResult PowerFractalDE(float3 pos, int fractalType, float power)
	{
		float3 z = pos;
		float dr = 1.0;
		float r = 0.0;
		int i;

		for (i = 0; i < FRACTAL_DE_MAX_ITER; i++)
		{
			r = length(z);
			if (r > FRACTAL_DE_BAILOUT)
				break;

			dr = pow(r, power - 1.0) * power * dr + 1.0;

			switch (fractalType)
			{
				case FRACTAL_TYPE_MANDELBULB:
					z = MandelbulbTransform(z, pos, power);
					break;
				case FRACTAL_TYPE_BURNING_SHIP:
					z = BurningShipTransform(z, pos, power);
					break;
				case FRACTAL_TYPE_JULIA_SET:
					z = JuliaSetTransform(z, pos, power);
					break;
			}
		}

		return MakeDEResult(r, dr, i);
	}

	// ============================================================================
	// IFS FRACTALS - Iterated Function Systems (geometric folding)
	// Uses repeated folding/inversion operations for crisp, geometric structures
	// ============================================================================

	static DEResult IFSFractalDE(float3 pos, float power, int fractalType)
	{
		float3 z = pos;
		float dr = 1.0;
		float scale = power;
		int i;
		
		for (i = 0; i < FRACTAL_DE_MAX_ITER; i++)
		{
			switch (fractalType)
			{
				case FRACTAL_TYPE_MANDELBOX:
					MandelboxLoop(z, dr, pos, scale);
					break;
				case FRACTAL_TYPE_INVERTED_MENGER:
					InvertedMengerLoop(z, dr, pos, scale);
					break;
				case FRACTAL_TYPE_KLEINIAN:
					KleinianLoop(z, dr, pos, scale);
					break;
				case FRACTAL_TYPE_APOLLONIAN:
					ApollonianLoop(z, dr, pos, scale);
					break;
				case FRACTAL_TYPE_SIERPINSKI_TETRAHEDRON:
					SierpinskiTetrahedronLoop(z, dr, pos, scale);
					break;
				case FRACTAL_TYPE_KALEIDOSCOPIC_IFS:
					KaleidoscopicIFSLoop(z, dr, pos, scale);
					break;
			}
			
			if (dot(z, z) > FRACTAL_DE_BAILOUT * FRACTAL_DE_BAILOUT)
				break;
		}
		
		return MakeDEResult(length(z), dr, i);
	}

	// ============================================================================
	// MAIN FRACTAL DISPATCHER - Routes to Power or IFS fractals
	// ============================================================================

	static DEResult FractalDE(float3 pos, int fractalType, float power)
	{
		switch (fractalType)
		{
			// Power Fractals: Smooth algebraic iteration
			case FRACTAL_TYPE_MANDELBULB:
			case FRACTAL_TYPE_BURNING_SHIP:
			case FRACTAL_TYPE_JULIA_SET:
				return PowerFractalDE(pos, fractalType, power);

			// IFS Fractals: Geometric folding
			case FRACTAL_TYPE_MANDELBOX:
			case FRACTAL_TYPE_INVERTED_MENGER:
			case FRACTAL_TYPE_KLEINIAN:
			case FRACTAL_TYPE_APOLLONIAN:
			case FRACTAL_TYPE_SIERPINSKI_TETRAHEDRON:
			case FRACTAL_TYPE_KALEIDOSCOPIC_IFS:
				return IFSFractalDE(pos, power, fractalType);

			// Special case: Quaternion (hybrid approach)
			case FRACTAL_TYPE_QUATERNION:
				return QuaternionDE(pos, power);

			default:
				return PowerFractalDE(pos, FRACTAL_TYPE_MANDELBULB, power);
		}
	}

	// Marching function
	static MarchResult MarchFractal(float3 RayOrigin, float3 RayDir, int fractalType, float power)
	{
		float totalDist = 0.0;
		int steps = 0;
		int totalDEIterations = 0;

		while (totalDist < FRACTAL_MARCH_MAX_DISTANCE && steps < FRACTAL_MARCH_MAX_STEPS)
		{
			steps++;
			float3 pos = RayOrigin + RayDir * totalDist;
			DEResult deResult = FractalDE(pos, fractalType, power);
			
			// Accumulate total DE iterations
			totalDEIterations += deResult.iterations;

			// Calculate precision threshold based on whether we're cone marching or ray marching
			float pixelSize = GetPixelWorldRadius(totalDist);
			float threshold = pixelSize;

			// Check if we've hit the fractal
			if (deResult.distance <= threshold)
			{
				MarchResult result;
				result.distance = totalDist;
				result.steps = steps;
				result.hitStatus = HIT_STATUS_HIT;
				result.totalDEIterations = totalDEIterations;
				return result;
			}

			// Advance by the distance estimate, with minimum step to avoid precision issues
			float stepSize = max(deResult.distance, pixelSize * 0.5); // Never step smaller than half a pixel
			totalDist += stepSize;
		}

		MarchResult result;
		result.distance = totalDist;
		result.steps = steps;
		result.hitStatus = (totalDist >= FRACTAL_MARCH_MAX_DISTANCE) ? HIT_STATUS_MISS_DISTANCE : HIT_STATUS_MISS_STEPS;
		result.totalDEIterations = totalDEIterations;
		return result;
	}

	static float3 RenderFractal(float2 screenUV, float3 sceneColor, int fractalType, float power, float scaleMultiplier)
	{
		// Get camera parameters
		float3 cameraOrigin = LWCHackToFloat(ResolvedView.WorldCameraOrigin);

		// Convert screen UV to clip space
		float2 clipXY = screenUV * 2.0 - 1.0;
		clipXY.y = -clipXY.y; // Flip Y for clip space

		float4 clipPos = float4(clipXY, 1.0, 1.0);
		float4 viewPos = mul(clipPos, ResolvedView.ClipToView);
		viewPos.xyz /= viewPos.w;

		// Transform view direction to world space
		float3 worldDir = normalize(mul(viewPos.xyz, (float3x3)ResolvedView.ViewToTranslatedWorld));

		// Scale the camera origin by the scale multiplier
		float3 rayOrigin = cameraOrigin * scaleMultiplier;
		float3 rayDir = worldDir;

		// Ray march
		MarchResult finalResult = MarchFractal(rayOrigin, rayDir, fractalType, power);

		// Calculate color based on total steps taken
		float stepFactor = saturate(finalResult.steps / float(FRACTAL_MARCH_MAX_STEPS));
		float t = sqrt(stepFactor);
		
		// Gradient color stops: position -> color
		float  almostBlackPos = 0.0;   float3 almostBlack = float3(0.0, 0.0, 0.05);    // Very few steps
		float  deepBluePos = 0.15;     float3 deepBlue = float3(0.05, 0.15, 0.3);      // Low detail areas
		float  vibrantBluePos = 0.4;   float3 vibrantBlue = float3(0.2, 0.4, 0.8);     // Medium detail
		float  brightBluePos = 1.0;    float3 brightBlue = float3(0.6, 0.8, 1.0);      // Many steps
		
		// Blend through gradient stops
		float range1 = saturate((t - almostBlackPos) / (deepBluePos - almostBlackPos));
		float range2 = saturate((t - deepBluePos) / (vibrantBluePos - deepBluePos));
		float range3 = saturate((t - vibrantBluePos) / (brightBluePos - vibrantBluePos));
		float3 fractalColor = lerp(lerp(lerp(almostBlack, deepBlue, range1), vibrantBlue, range2), brightBlue, range3);

		// Add green tint based on total DE iterations
		float iterFactor = saturate(finalResult.totalDEIterations / float(FRACTAL_DE_MAX_ITER * finalResult.steps));
		float greenThreshold = 0.1;
		if (iterFactor > greenThreshold)
		{
			// Steep exponential curve from greenThreshold to 1.0
			float greenAmount = (iterFactor - greenThreshold) / (1.0 - greenThreshold);
			greenAmount = pow(greenAmount, 2.0); // Quadratic for steep ramp
			fractalColor = lerp(fractalColor, float3(0.3, 0.5, 0.6), greenAmount);
		}

		float greenPeak = 0.9;
		if (iterFactor > greenPeak)
		{
			// Steep exponential curve from greenPeak to 1.0
			float greenAmount = (iterFactor - greenPeak) / (1.0 - greenPeak);
			greenAmount = pow(greenAmount, 5.0); // Quadratic for steep ramp
			fractalColor = lerp(fractalColor, float3(0.3, 0.9, 0.7), greenAmount);
		}

		if (finalResult.hitStatus == HIT_STATUS_HIT)
		{
			// Direct hit: show fractal color
			return fractalColor;
		}
		else if (finalResult.hitStatus == HIT_STATUS_MISS_DISTANCE)
		{
			// Missed due to distance: blend fractal color with scene color based on steps taken
			float fogAmount = pow(stepFactor, 0.1);
			return lerp(sceneColor, fractalColor, fogAmount);
		}
		else if (finalResult.hitStatus == HIT_STATUS_MISS_STEPS)
		{
			// Missed due to max steps: show fractal color (TODO: Find a better way to handle this case, use depth?)
			return fractalColor;
		}
		else
		{
			// Should not happen, fallback to scene color
			return sceneColor;
		}
	}

	// ============================================================================
	// SHARED UTILITY FUNCTIONS
	// ============================================================================
	
	// Box folding - reflects coordinates through box boundaries (IFS building block)
	static void BoxFold(inout float3 z, float foldingLimit)
	{
		z.x = clamp(z.x, -foldingLimit, foldingLimit) * 2.0 - z.x;
		z.y = clamp(z.y, -foldingLimit, foldingLimit) * 2.0 - z.y;
		z.z = clamp(z.z, -foldingLimit, foldingLimit) * 2.0 - z.z;
	}

	// Sphere folding - inverts points through spherical boundaries (IFS building block)
	static void SphereFold(inout float3 z, inout float dr, float minRadius, float fixedRadius)
	{
		float r2 = dot(z, z);
		float minRadius2 = minRadius * minRadius;
		float fixedRadius2 = fixedRadius * fixedRadius;

		if (r2 < minRadius2)
		{
			float temp = fixedRadius2 / minRadius2;
			z *= temp;
			dr *= temp;
		}
		else if (r2 < fixedRadius2)
		{
			float temp = fixedRadius2 / r2;
			z *= temp;
			dr *= temp;
		}
	}
	
	// Tetrahedral folding - creates 4-faced pyramid symmetry
	static void TetrahedralFold(inout float3 z)
	{
		if (z.x + z.y < 0.0) z.xy = -z.yx;
		if (z.x + z.z < 0.0) z.xz = -z.zx;
		if (z.y + z.z < 0.0) z.yz = -z.zy;
	}
	
	// Octahedral folding - creates 8-faced symmetry
	static void OctahedralFold(inout float3 z)
	{
		z = abs(z);
		SortComponents(z);
	}
	
	// Tetrahedral folding followed by component sorting (for Sierpinski-type fractals)
	static void TetrahedralSortFold(inout float3 z)
	{
		TetrahedralFold(z);
		SortComponents(z);
	}

	// Component sorting - sorts components in descending order
	static void SortComponents(inout float3 z)
	{
		if (z.x < z.y) z.xy = z.yx;
		if (z.x < z.z) z.xz = z.zx;
		if (z.y < z.z) z.yz = z.zy;
	}
	

	// Spherical power transformation (Mandelbulb-style)
	static float3 SphericalPowerTransform(float3 z, float power)
	{
		SphericalCoords coords = CartesianToSpherical(z);
		float zr = pow(coords.r, power);
		RotateSpherical(coords.theta, coords.phi, power);
		return SphericalToCartesian(zr, coords.theta, coords.phi);
	}

	// ============================================================================
	// Specific Fractal Transformations
	// ============================================================================
	
	static float3 MandelbulbTransform(float3 z, float3 pos, float power)
	{
		return SphericalPowerTransform(z, power) + pos;
	}
	
	static float3 BurningShipTransform(float3 z, float3 pos, float power)
	{
		return SphericalPowerTransform(abs(z), power) + pos;
	}
	
	static float3 JuliaSetTransform(float3 z, float3 pos, float power)
	{
		float3 c = float3(-0.8, 0.156, 0.0);
		return SphericalPowerTransform(z, power) + c;
	}

	// ============================================================================
	// Distance Estimator Loop Bodies (The unique part of each fractal)
	// ============================================================================
	
	static void MandelboxLoop(inout float3 z, inout float dr, float3 pos, float scale)
	{
		const float foldingLimit = 1.0;
		const float minRadius = 0.5;
		const float fixedRadius = 1.0;
		
		BoxFold(z, foldingLimit);
		SphereFold(z, dr, minRadius, fixedRadius);
		
		z = z * scale + pos;
		dr = dr * abs(scale) + 1.0;
	}
	
	static void InvertedMengerLoop(inout float3 z, inout float dr, float3 pos, float scale)
	{
		OctahedralFold(z);
		
		z = z * scale - float3(1.0, 1.0, 1.0) * (scale - 1.0);
		dr *= scale;
	}
	
	static void KleinianLoop(inout float3 z, inout float dr, float3 pos, float scale)
	{
		const float minRadius = 0.3;
		const float fixedRadius = 1.0;
		
		SphereFold(z, dr, minRadius, fixedRadius);
		
		z = z * scale + pos;
		dr = dr * abs(scale) + 1.0;
	}
	
	static void ApollonianLoop(inout float3 z, inout float dr, float3 pos, float scale)
	{
		const float3 center1 = float3(1.0, 1.0, 1.0);
		const float3 center2 = float3(1.0, -1.0, -1.0);
		const float3 center3 = float3(-1.0, 1.0, -1.0);
		const float3 center4 = float3(-1.0, -1.0, 1.0);
		const float radius = 1.0;
		
		float3 diff1 = z - center1;
		float3 diff2 = z - center2;
		float3 diff3 = z - center3;
		float3 diff4 = z - center4;
		
		float d1 = dot(diff1, diff1);
		float d2 = dot(diff2, diff2);
		float d3 = dot(diff3, diff3);
		float d4 = dot(diff4, diff4);
		
		float3 closest = center1;
		float closestD = d1;
		
		if (d2 < closestD) { closest = center2; closestD = d2; }
		if (d3 < closestD) { closest = center3; closestD = d3; }
		if (d4 < closestD) { closest = center4; closestD = d4; }
		
		float3 diff = z - closest;
		float r2 = dot(diff, diff);
		float k = radius * radius / max(r2, 0.01);
		z = closest + diff * k;
		dr *= k;
		
		z *= scale;
		dr *= scale;
	}
	
	static void SierpinskiTetrahedronLoop(inout float3 z, inout float dr, float3 pos, float scale)
	{
		TetrahedralSortFold(z);
		
		z = z * scale - float3(1.0, 1.0, 1.0) * (scale - 1.0);
		dr *= scale;
	}
	
	static void KaleidoscopicIFSLoop(inout float3 z, inout float dr, float3 pos, float scale)
	{
		const float minRadius = 0.5;
		const float fixedRadius = 1.0;
		
		OctahedralFold(z);
		SphereFold(z, dr, minRadius, fixedRadius);
		
		z = z * scale + pos;
		dr = dr * abs(scale) + 1.0;
	}

	// ============================================================================
	// Distance Estimator Functions
	// ============================================================================
	
	static DEResult QuaternionDE(float3 pos, float power)
	{
		float4 z = float4(pos, 0.0);
		float4 c = float4(pos, 0.0);
		float dr = 1.0;
		int i;
		
		for (i = 0; i < FRACTAL_DE_MAX_ITER; i++)
		{
			float r = length(z);
			if (r > FRACTAL_DE_BAILOUT)
				break;
			
			// Quaternion multiplication (z^power)
			float theta = acos(z.w / r) * power;
			float phi = atan2(z.y, z.x) * power;
			float zr = pow(r, power);
			
			float sinTheta = sin(theta);
			z = float4(
				zr * sinTheta * cos(phi),
				zr * sinTheta * sin(phi),
				zr * cos(theta),
				0.0
			);
			
			z += c;
			dr = pow(r, power - 1.0) * power * dr + 1.0;
		}
		
		float r = length(z);

		return MakeDEResult(r, dr, i);
	}
};

// Usage in material custom node:
// #include "/Project/FractalMaterial.usf"
// FractalFunctions FF;
// return FF.RenderFractal(ScreenPosition, SceneColor, FractalType, Power, ScaleMultiplier).rgb;
//
// Parameters:
// - FractalType: Integer fractal type (see values below)
// - Power: Float power parameter (typically 1.0-19.0)
// - ScaleMultiplier: Float world scale (0.0001-0.01, default 0.001) - controls zoom level/world size
//
// FractalType values:
// 0 = Mandelbulb
// 1 = Burning Ship
// 2 = Julia Set
// 3 = Mandelbox
// 4 = Inverted Menger (cube-based IFS with holes as surface)
// 5 = Kleinian (bubble-like sphere inversions)
// 6 = Apollonian (sphere packing)
// 7 = Quaternion (4D Julia set)
// 8 = Sierpinski Tetrahedron (triangular pyramid fractal with 4 faces)
// 9 = Kaleidoscopic IFS (complex mirrored patterns)